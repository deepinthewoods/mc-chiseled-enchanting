This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-02T13:18:49.645Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
client/java/ninja/trek/chiseledenchanting/ChiseledEnchantingClient.java
client/java/ninja/trek/chiseledenchanting/ChiseledEnchantingModMenu.java
client/java/ninja/trek/chiseledenchanting/ChiseledEnchantmentTableBlockEntityRenderer.java
client/java/ninja/trek/chiseledenchanting/mixin/client/ExampleClientMixin.java
client/resources/chiseled-enchanting.client.mixins.json
main/java/ninja/trek/chiseledenchanting/ChiseledEnchanting.java
main/java/ninja/trek/chiseledenchanting/ChiseledEnchantingConfig.java
main/java/ninja/trek/chiseledenchanting/ChiseledEnchantingDataGenerator.java
main/java/ninja/trek/chiseledenchanting/ChiseledEnchantmentScreenHandler.java
main/java/ninja/trek/chiseledenchanting/ChiseledEnchantmentTableBlock.java
main/java/ninja/trek/chiseledenchanting/ChiseledEnchantmentTableBlockEntity.java
main/java/ninja/trek/chiseledenchanting/mixin/EnchantmentScreenHandlerAccessor.java
main/java/ninja/trek/chiseledenchanting/mixin/EnchantmentScreenHandlerMixin.java
main/java/ninja/trek/chiseledenchanting/mixin/ExampleMixin.java
main/resources/assets/chiseled-enchanting/blockstates/chiseled_enchanting_table.json
main/resources/assets/chiseled-enchanting/lang/en_us.json
main/resources/assets/chiseled-enchanting/models/block/chiseled_enchanting_table.json
main/resources/assets/chiseled-enchanting/models/item/chiseled_enchanting_table.json
main/resources/chiseled-enchanting.mixins.json
main/resources/fabric.mod.json
repomixx.bat
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="client/java/ninja/trek/chiseledenchanting/ChiseledEnchantingClient.java">
package ninja.trek.chiseledenchanting;
import net.fabricmc.api.ClientModInitializer;
import net.fabricmc.api.EnvType;
import net.fabricmc.api.Environment;
import net.fabricmc.fabric.api.client.rendering.v1.BlockEntityRendererRegistry;
@Environment(EnvType.CLIENT)
public class ChiseledEnchantingClient implements ClientModInitializer {
	@Override
	public void onInitializeClient() {
		// This entrypoint is suitable for setting up client-specific logic, such as rendering.
		BlockEntityRendererRegistry.register(
				ChiseledEnchanting.CHISELED_ENCHANTING_TABLE_BLOCK_ENTITY,
				ChiseledEnchantmentTableBlockEntityRenderer::new
		);
	}
}
</file>

<file path="client/java/ninja/trek/chiseledenchanting/ChiseledEnchantingModMenu.java">
package ninja.trek.chiseledenchanting;
import com.terraformersmc.modmenu.api.ConfigScreenFactory;
import com.terraformersmc.modmenu.api.ModMenuApi;
import net.minecraft.text.Text;
import me.shedaniel.clothconfig2.api.ConfigBuilder;
import me.shedaniel.clothconfig2.api.ConfigCategory;
import me.shedaniel.clothconfig2.api.ConfigEntryBuilder;
public class ChiseledEnchantingModMenu implements ModMenuApi {
    @Override
    public ConfigScreenFactory<?> getModConfigScreenFactory() {
        System.out.println("ModMenu Screen is Loading!"); // Debug output
        return parent -> {
            ConfigBuilder builder = ConfigBuilder.create()
                    .setParentScreen(parent)
                    .setTitle(Text.translatable("config.chiseled-enchanting.title"));
            ConfigCategory general = builder.getOrCreateCategory(Text.translatable("config.chiseled-enchanting.category.general"));
            ConfigEntryBuilder entryBuilder = builder.entryBuilder();
            general.addEntry(entryBuilder.startBooleanToggle(
                            Text.translatable("config.chiseled-enchanting.option.enable_weighting"),
                            ChiseledEnchantingConfig.get().enableWeighting)
                    .setDefaultValue(true)
                    .setSaveConsumer(newValue -> {
                        ChiseledEnchantingConfig.get().enableWeighting = newValue;
                        ChiseledEnchantingConfig.save();
                    })
                    .build());
            general.addEntry(entryBuilder.startBooleanToggle(
                            Text.translatable("config.chiseled-enchanting.option.inverse_books"),
                            ChiseledEnchantingConfig.get().inverseWeightingForBooks)
                    .setDefaultValue(true)
                    .setSaveConsumer(newValue -> {
                        ChiseledEnchantingConfig.get().inverseWeightingForBooks = newValue;
                        ChiseledEnchantingConfig.save();
                    })
                    .build());
            general.addEntry(entryBuilder.startBooleanToggle(
                            Text.translatable("config.chiseled-enchanting.option.invert_items"),
                            ChiseledEnchantingConfig.get().inverseWeightingForItems)
                    .setDefaultValue(false)
                    .setSaveConsumer(newValue -> {
                        ChiseledEnchantingConfig.get().inverseWeightingForItems = newValue;
                        ChiseledEnchantingConfig.save();
                    })
                    .build());
            return builder.build();
        };
    }
}
</file>

<file path="client/java/ninja/trek/chiseledenchanting/ChiseledEnchantmentTableBlockEntityRenderer.java">
package ninja.trek.chiseledenchanting;
import net.fabricmc.api.EnvType;
import net.fabricmc.api.Environment;
import net.minecraft.client.render.RenderLayer;
import net.minecraft.client.render.VertexConsumer;
import net.minecraft.client.render.VertexConsumerProvider;
import net.minecraft.client.render.block.entity.BlockEntityRenderer;
import net.minecraft.client.render.block.entity.BlockEntityRendererFactory;
import net.minecraft.client.render.entity.model.BookModel;
import net.minecraft.client.render.entity.model.EntityModelLayers;
import net.minecraft.client.texture.SpriteAtlasTexture;
import net.minecraft.client.util.SpriteIdentifier;
import net.minecraft.client.util.math.MatrixStack;
import net.minecraft.util.Identifier;
import net.minecraft.util.math.MathHelper;
import net.minecraft.util.math.RotationAxis;
import ninja.trek.chiseledenchanting.ChiseledEnchantmentTableBlockEntity;
@Environment(EnvType.CLIENT)
public class ChiseledEnchantmentTableBlockEntityRenderer implements BlockEntityRenderer<ChiseledEnchantmentTableBlockEntity> {
    public static final SpriteIdentifier BOOK_TEXTURE;
    private final BookModel book;
    public ChiseledEnchantmentTableBlockEntityRenderer(BlockEntityRendererFactory.Context ctx) {
        this.book = new BookModel(ctx.getLayerModelPart(EntityModelLayers.BOOK));
    }
    @Override
    public void render(ChiseledEnchantmentTableBlockEntity entity, float tickDelta, MatrixStack matrices, VertexConsumerProvider vertexConsumers, int light, int overlay) {
        matrices.push();
        matrices.translate(0.5F, 0.75F, 0.5F);
        float time = (entity.getWorld() != null) ? (entity.getWorld().getTime() + tickDelta) : 0;
        matrices.translate(0.0F, 0.1F + MathHelper.sin(time * 0.1F) * 0.01F, 0.0F);
        float rotationDiff;
        for (rotationDiff = entity.bookRotation - entity.lastBookRotation; rotationDiff >= Math.PI; rotationDiff -= (Math.PI * 2F)) {
        }
        while (rotationDiff < -Math.PI) {
            rotationDiff += (Math.PI * 2F);
        }
        float bookRotation = entity.lastBookRotation + rotationDiff * tickDelta;
        matrices.multiply(RotationAxis.POSITIVE_Y.rotation(-bookRotation));
        matrices.multiply(RotationAxis.POSITIVE_Z.rotationDegrees(80.0F));
        float pageAngle = MathHelper.lerp(tickDelta, entity.pageAngle, entity.nextPageAngle);
        float leftPage = MathHelper.fractionalPart(pageAngle + 0.25F) * 1.6F - 0.3F;
        float rightPage = MathHelper.fractionalPart(pageAngle + 0.75F) * 1.6F - 0.3F;
        float pageTurningSpeed = MathHelper.lerp(tickDelta, entity.pageTurningSpeed, entity.nextPageTurningSpeed);
        this.book.setPageAngles(time, MathHelper.clamp(leftPage, 0.0F, 1.0F), MathHelper.clamp(rightPage, 0.0F, 1.0F), pageTurningSpeed);
        VertexConsumer vertexConsumer = BOOK_TEXTURE.getVertexConsumer(vertexConsumers, RenderLayer::getEntitySolid);
        this.book.renderBook(matrices, vertexConsumer, light, overlay, -1);
        matrices.pop();
    }
    static {
        BOOK_TEXTURE = new SpriteIdentifier(SpriteAtlasTexture.BLOCK_ATLAS_TEXTURE, Identifier.of("entity/enchanting_table_book"));
    }
}
</file>

<file path="client/java/ninja/trek/chiseledenchanting/mixin/client/ExampleClientMixin.java">
package ninja.trek.chiseledenchanting.mixin.client;
import net.minecraft.client.MinecraftClient;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftClient.class)
public class ExampleClientMixin {
	@Inject(at = @At("HEAD"), method = "run")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftClient.run()V
	}
}
</file>

<file path="client/resources/chiseled-enchanting.client.mixins.json">
{
	"required": true,
	"package": "ninja.trek.chiseledenchanting.mixin.client",
	"compatibilityLevel": "JAVA_21",
	"client": [
		"ExampleClientMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="main/java/ninja/trek/chiseledenchanting/ChiseledEnchanting.java">
package ninja.trek.chiseledenchanting;
import net.fabricmc.api.ModInitializer;
import net.fabricmc.fabric.api.item.v1.FabricItem;
import net.fabricmc.fabric.api.object.builder.v1.block.FabricBlockSettings;
import net.fabricmc.fabric.api.object.builder.v1.block.entity.FabricBlockEntityTypeBuilder;
import net.minecraft.block.Block;
import net.minecraft.block.Blocks;
import net.minecraft.block.entity.BlockEntityType;
import net.minecraft.item.BlockItem;
import net.minecraft.item.Item;
import net.minecraft.registry.Registries;
import net.minecraft.registry.Registry;
import net.minecraft.util.Identifier;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class ChiseledEnchanting implements ModInitializer {
	public static final String MOD_ID = "chiseled-enchanting";
	public static final Logger LOGGER = LoggerFactory.getLogger(MOD_ID);
	public static final Block CHISELED_ENCHANTING_TABLE = new ChiseledEnchantmentTableBlock(
			FabricBlockSettings.copyOf(Blocks.ENCHANTING_TABLE)
	);
	public static final BlockEntityType<ChiseledEnchantmentTableBlockEntity> CHISELED_ENCHANTING_TABLE_BLOCK_ENTITY =
			FabricBlockEntityTypeBuilder.create(
					ChiseledEnchantmentTableBlockEntity::new,
					CHISELED_ENCHANTING_TABLE
			).build();
	@Override
	public void onInitialize() {
		Registry.register(
				Registries.BLOCK_ENTITY_TYPE,
				Identifier.of(MOD_ID, "chiseled_enchanting_table"),
				CHISELED_ENCHANTING_TABLE_BLOCK_ENTITY
		);
		Registry.register(
				Registries.BLOCK,
				Identifier.of(MOD_ID, "chiseled_enchanting_table"),
				CHISELED_ENCHANTING_TABLE
		);
		Registry.register(
				Registries.ITEM,
				Identifier.of(MOD_ID, "chiseled_enchanting_table"),
				new BlockItem(CHISELED_ENCHANTING_TABLE, new Item.Settings())
		);
		LOGGER.info("Chiseled Enchanting mod initialized!");
	}
}
</file>

<file path="main/java/ninja/trek/chiseledenchanting/ChiseledEnchantingConfig.java">
package ninja.trek.chiseledenchanting;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import net.fabricmc.loader.api.FabricLoader;
import java.nio.file.Files;
import java.nio.file.Path;
public class ChiseledEnchantingConfig {
    private static final Path CONFIG_PATH = FabricLoader.getInstance().getConfigDir().resolve("chiseled-enchanting.json");
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
    private static ChiseledEnchantingConfig INSTANCE;
    public boolean inverseWeightingForBooks = true;
    public boolean inverseWeightingForItems = false; // Default value
    public boolean enableWeighting = true;
    public static ChiseledEnchantingConfig get() {
        if (INSTANCE == null) {
            load();
        }
        return INSTANCE;
    }
    public static void load() {
        try {
            if (Files.exists(CONFIG_PATH)) {
                INSTANCE = GSON.fromJson(Files.readString(CONFIG_PATH), ChiseledEnchantingConfig.class);
            } else {
                INSTANCE = new ChiseledEnchantingConfig();
                save();
            }
        } catch (Exception e) {
            ChiseledEnchanting.LOGGER.error("Failed to load config", e);
            INSTANCE = new ChiseledEnchantingConfig();
        }
    }
    public static void save() {
        try {
            Files.writeString(CONFIG_PATH, GSON.toJson(INSTANCE));
        } catch (Exception e) {
            ChiseledEnchanting.LOGGER.error("Failed to save config", e);
        }
    }
}
</file>

<file path="main/java/ninja/trek/chiseledenchanting/ChiseledEnchantingDataGenerator.java">
package ninja.trek.chiseledenchanting;
import net.fabricmc.fabric.api.datagen.v1.DataGeneratorEntrypoint;
import net.fabricmc.fabric.api.datagen.v1.FabricDataGenerator;
import net.fabricmc.fabric.api.datagen.v1.provider.FabricBlockLootTableProvider;
import net.fabricmc.fabric.api.datagen.v1.provider.FabricRecipeProvider;
import net.minecraft.data.server.recipe.RecipeExporter;
import net.minecraft.data.server.recipe.ShapedRecipeJsonBuilder;
import net.minecraft.item.Items;
import net.minecraft.recipe.book.RecipeCategory;
import net.minecraft.util.Identifier;
public class ChiseledEnchantingDataGenerator implements DataGeneratorEntrypoint {
    @Override
    public void onInitializeDataGenerator(FabricDataGenerator fabricDataGenerator) {
        FabricDataGenerator.Pack pack = fabricDataGenerator.createPack();
        pack.addProvider((output, registriesFuture) -> new FabricRecipeProvider(output, registriesFuture) {
            @Override
            public void generate(RecipeExporter exporter) {
                ShapedRecipeJsonBuilder.create(RecipeCategory.DECORATIONS, ChiseledEnchanting.CHISELED_ENCHANTING_TABLE)
                        .pattern(" B ")
                        .pattern("DTD")
                        .pattern("OOO")
                        .input('B', Items.BOOK)
                        .input('D', Items.DIAMOND)
                        .input('T', Items.ENCHANTING_TABLE)
                        .input('O', Items.OBSIDIAN)
                        .criterion(FabricRecipeProvider.hasItem(Items.ENCHANTING_TABLE),
                                FabricRecipeProvider.conditionsFromItem(Items.ENCHANTING_TABLE))
                        .offerTo(exporter, Identifier.of(ChiseledEnchanting.MOD_ID, "chiseled_enchanting_table"));
            }
        });
        pack.addProvider((output, registriesFuture) -> new FabricBlockLootTableProvider(output, registriesFuture) {
            @Override
            public void generate() {
                addDrop(ChiseledEnchanting.CHISELED_ENCHANTING_TABLE);
            }
        });
    }
}
</file>

<file path="main/java/ninja/trek/chiseledenchanting/ChiseledEnchantmentScreenHandler.java">
package ninja.trek.chiseledenchanting;
import net.minecraft.screen.EnchantmentScreenHandler;
import net.minecraft.screen.ScreenHandlerContext;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.entity.player.PlayerInventory;
import ninja.trek.chiseledenchanting.mixin.EnchantmentScreenHandlerAccessor;
public class ChiseledEnchantmentScreenHandler extends EnchantmentScreenHandler {
    public ChiseledEnchantmentScreenHandler(int syncId, PlayerInventory inventory, ScreenHandlerContext context) {
        super(syncId, inventory, context);
    }
    @Override
    public boolean canUse(PlayerEntity player) {
        // Use the mixin accessor to obtain the context, since the field is private
        ScreenHandlerContext context = ((EnchantmentScreenHandlerAccessor)this).getContext();
        return context.get((world, pos) ->
                world.getBlockState(pos).isOf(ChiseledEnchanting.CHISELED_ENCHANTING_TABLE), true);
    }
}
</file>

<file path="main/java/ninja/trek/chiseledenchanting/ChiseledEnchantmentTableBlock.java">
package ninja.trek.chiseledenchanting;
import com.mojang.serialization.Decoder;
import com.mojang.serialization.Encoder;
import com.mojang.serialization.MapCodec;
import net.minecraft.block.*;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.block.entity.BlockEntityTicker;
import net.minecraft.block.entity.BlockEntityType;
import net.minecraft.screen.*;
import net.minecraft.text.Text;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.BlockView;
import net.minecraft.world.World;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.util.ActionResult;
import net.minecraft.util.Hand;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.shape.VoxelShape;
import net.minecraft.util.shape.VoxelShapes;
import org.jetbrains.annotations.Nullable;
import net.minecraft.block.AbstractBlock;
public class ChiseledEnchantmentTableBlock extends BlockWithEntity {
    private static final VoxelShape SHAPE = Block.createCuboidShape(0.0, 0.0, 0.0, 16.0, 12.0, 16.0);
//    private static final VoxelShape FLOATING_BOOK_SHAPE = Block.createCuboidShape(4.0, 12.0, 4.0, 12.0, 14.0, 12.0);
//    private static final VoxelShape SHAPE = VoxelShapes.union(BASE_SHAPE, FLOATING_BOOK_SHAPE);
    public ChiseledEnchantmentTableBlock(Settings settings) {
        super(settings);
    }
    @Override
    protected MapCodec<ChiseledEnchantmentTableBlock> getCodec() {
        return MapCodec.of(Encoder.empty(), Decoder.unit(this));
    }
    @Nullable
    protected static <E extends BlockEntity, T extends BlockEntity> BlockEntityTicker<T> checkType(World world,
                                                                                                   BlockEntityType<T> givenType, BlockEntityType<E> expectedType, BlockEntityTicker<? super E> ticker) {
        return expectedType == givenType ? (BlockEntityTicker<T>) ticker : null;
    }
    @Override
    @Nullable
    public <T extends BlockEntity> BlockEntityTicker<T> getTicker(World world, BlockState state, BlockEntityType<T> type) {
        return world.isClient ? checkType(world, type, ChiseledEnchanting.CHISELED_ENCHANTING_TABLE_BLOCK_ENTITY,
                ChiseledEnchantmentTableBlockEntity::tick) : null;
    }
    @Override
    public BlockRenderType getRenderType(BlockState state) {
        return BlockRenderType.MODEL;
    }
    @Override
    public BlockEntity createBlockEntity(BlockPos pos, BlockState state) {
        return new ChiseledEnchantmentTableBlockEntity(pos, state);
    }
    @Override
    public VoxelShape getOutlineShape(BlockState state, BlockView world, BlockPos pos, ShapeContext context) {
        return SHAPE;
    }
    @Override
    protected ActionResult onUse(BlockState state, World world, BlockPos pos, PlayerEntity player, BlockHitResult hit) {
        if (world.isClient) {
            return ActionResult.SUCCESS;
        }
        BlockEntity blockEntity = world.getBlockEntity(pos);
        if (blockEntity instanceof ChiseledEnchantmentTableBlockEntity) {
            player.openHandledScreen(state.createScreenHandlerFactory(world, pos));
            return ActionResult.CONSUME;
        }
        return ActionResult.PASS;
    }
    @Override
    public NamedScreenHandlerFactory createScreenHandlerFactory(BlockState state, World world, BlockPos pos) {
        return new SimpleNamedScreenHandlerFactory((syncId, inventory, player) ->
                new ChiseledEnchantmentScreenHandler(syncId, inventory, ScreenHandlerContext.create(world, pos)),
                Text.translatable("container.enchant")
        );
    }
    @Override
    public void onStateReplaced(BlockState state, World world, BlockPos pos, BlockState newState, boolean moved) {
        if (state.getBlock() != newState.getBlock()) {
            BlockEntity blockEntity = world.getBlockEntity(pos);
            if (blockEntity instanceof ChiseledEnchantmentTableBlockEntity) {
                // Handle any cleanup if needed
            }
            super.onStateReplaced(state, world, pos, newState, moved);
        }
    }
}
</file>

<file path="main/java/ninja/trek/chiseledenchanting/ChiseledEnchantmentTableBlockEntity.java">
package ninja.trek.chiseledenchanting;
import net.minecraft.block.BlockState;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.component.DataComponentTypes;
import net.minecraft.component.type.ItemEnchantmentsComponent;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.inventory.Inventory;
import net.minecraft.item.ItemStack;
import net.minecraft.item.Items;
import net.minecraft.nbt.NbtCompound;
import net.minecraft.registry.RegistryWrapper;
import net.minecraft.registry.entry.RegistryEntry;
import net.minecraft.text.Text;
import net.minecraft.text.Text.Serialization;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.MathHelper;
import net.minecraft.util.math.random.Random;
import net.minecraft.world.World;
import net.minecraft.enchantment.Enchantment;
import net.minecraft.enchantment.EnchantmentHelper;
import java.util.HashMap;
import java.util.Map;
import org.jetbrains.annotations.Nullable;
public class ChiseledEnchantmentTableBlockEntity extends BlockEntity {
    public int ticks;
    public float nextPageAngle;
    public float pageAngle;
    public float flipRandom;
    public float flipTurn;
    public float nextPageTurningSpeed;
    public float pageTurningSpeed;
    public float bookRotation;
    public float lastBookRotation;
    public float targetBookRotation;
    private static final Random RANDOM = Random.create();
    private final Map<Enchantment, Integer> enchantmentBoosts = new HashMap<>();
    @Nullable
    private Text customName;
    public ChiseledEnchantmentTableBlockEntity(BlockPos pos, BlockState state) {
        super(ChiseledEnchanting.CHISELED_ENCHANTING_TABLE_BLOCK_ENTITY, pos, state);
    }
    public static void tick(World world, BlockPos pos, BlockState state, ChiseledEnchantmentTableBlockEntity blockEntity) {
        blockEntity.pageTurningSpeed = blockEntity.nextPageTurningSpeed;
        blockEntity.lastBookRotation = blockEntity.bookRotation;
        // Track players nearby
        PlayerEntity playerEntity = world.getClosestPlayer(pos.getX() + 0.5, pos.getY() + 0.5, pos.getZ() + 0.5, 3.0, false);
        if (playerEntity != null) {
            double dx = playerEntity.getX() - (pos.getX() + 0.5);
            double dz = playerEntity.getZ() - (pos.getZ() + 0.5);
            blockEntity.targetBookRotation = (float) MathHelper.atan2(dz, dx);
            blockEntity.nextPageTurningSpeed += 0.1F;
            if (blockEntity.nextPageTurningSpeed < 0.5F || RANDOM.nextInt(40) == 0) {
                float oldFlipRandom = blockEntity.flipRandom;
                do {
                    blockEntity.flipRandom += RANDOM.nextInt(4) - RANDOM.nextInt(4);
                } while (oldFlipRandom == blockEntity.flipRandom);
            }
        } else {
            blockEntity.targetBookRotation += 0.02F;
            blockEntity.nextPageTurningSpeed -= 0.1F;
        }
        // Normalize book rotation
        while (blockEntity.bookRotation >= Math.PI) blockEntity.bookRotation -= (Math.PI * 2F);
        while (blockEntity.bookRotation < -Math.PI) blockEntity.bookRotation += (Math.PI * 2F);
        while (blockEntity.targetBookRotation >= Math.PI) blockEntity.targetBookRotation -= (Math.PI * 2F);
        while (blockEntity.targetBookRotation < -Math.PI) blockEntity.targetBookRotation += (Math.PI * 2F);
        // Smooth book rotation
        float rotationDiff = blockEntity.targetBookRotation - blockEntity.bookRotation;
        while (rotationDiff >= Math.PI) rotationDiff -= (Math.PI * 2F);
        while (rotationDiff < -Math.PI) rotationDiff += (Math.PI * 2F);
        blockEntity.bookRotation += rotationDiff * 0.4F;
        // Clamp page turning speed
        blockEntity.nextPageTurningSpeed = MathHelper.clamp(blockEntity.nextPageTurningSpeed, 0.0F, 1.0F);
        // Update tick count
        blockEntity.ticks++;
        blockEntity.pageAngle = blockEntity.nextPageAngle;
        // Smooth page turning animation
        float pageFlipDelta = (blockEntity.flipRandom - blockEntity.nextPageAngle) * 0.4F;
        pageFlipDelta = MathHelper.clamp(pageFlipDelta, -0.2F, 0.2F);
        blockEntity.flipTurn += (pageFlipDelta - blockEntity.flipTurn) * 0.9F;
        blockEntity.nextPageAngle += blockEntity.flipTurn;
        // Update enchantment boosts
        blockEntity.updateEnchantmentBoosts(world, pos);
    }
    private void updateEnchantmentBoosts(World world, BlockPos pos) {
        enchantmentBoosts.clear();
        for (BlockPos scanPos : BlockPos.iterate(pos.add(-2, 0, -2), pos.add(2, 3, 2))) {
            BlockState scanState = world.getBlockState(scanPos);
            if (scanState.getBlock() instanceof net.minecraft.block.ChiseledBookshelfBlock) {
                BlockEntity bookshelfEntity = world.getBlockEntity(scanPos);
                if (bookshelfEntity instanceof Inventory inventory) {
                    processBookshelfInventory(inventory);
                }
            }
        }
    }
    private void processBookshelfInventory(Inventory inventory) {
        for (int slot = 0; slot < inventory.size(); slot++) {
            ItemStack stack = inventory.getStack(slot);
            if (stack.isOf(Items.ENCHANTED_BOOK)) {
                var bookEnchants = stack.get(DataComponentTypes.ENCHANTMENTS).getEnchantments(); // List of Enchantment objects
                for (RegistryEntry<Enchantment> enchantment : bookEnchants) {
                    int currentBoost = enchantmentBoosts.getOrDefault(enchantment, 0);
                    enchantmentBoosts.put(enchantment.value(), Math.min(3, currentBoost + 1)); // Max boost of 3 books
                }
            }
        }
    }
    public float getEnchantmentBoost(Enchantment enchantment) {
        int bookCount = enchantmentBoosts.getOrDefault(enchantment, 0);
        float boost = (float) Math.pow(2, bookCount);
        return boost;
    }
    @Override
    protected void writeNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup registryLookup) {
        super.writeNbt(nbt, registryLookup);
        if (this.customName != null) {
            nbt.putString("CustomName", Text.Serialization.toJsonString(this.customName, registryLookup));
        }
    }
    @Override
    public void readNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup registryLookup) {
        super.readNbt(nbt, registryLookup);
        if (nbt.contains("CustomName", 8)) {
            this.customName = Text.Serialization.fromJson(nbt.getString("CustomName"), registryLookup);
        }
    }
    @Nullable
    public Text getCustomName() {
        return this.customName;
    }
    public void setCustomName(@Nullable Text customName) {
        this.customName = customName;
    }
}
</file>

<file path="main/java/ninja/trek/chiseledenchanting/mixin/EnchantmentScreenHandlerAccessor.java">
package ninja.trek.chiseledenchanting.mixin;
import net.minecraft.screen.EnchantmentScreenHandler;
import net.minecraft.screen.ScreenHandlerContext;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.gen.Accessor;
@Mixin(EnchantmentScreenHandler.class)
public interface EnchantmentScreenHandlerAccessor {
    @Accessor("context")
    ScreenHandlerContext getContext();
}
</file>

<file path="main/java/ninja/trek/chiseledenchanting/mixin/EnchantmentScreenHandlerMixin.java">
package ninja.trek.chiseledenchanting.mixin;
import net.minecraft.enchantment.EnchantmentLevelEntry;
import net.minecraft.item.ItemStack;
import net.minecraft.item.Items;
import net.minecraft.registry.DynamicRegistryManager;
import net.minecraft.screen.EnchantmentScreenHandler;
import ninja.trek.chiseledenchanting.ChiseledEnchanting;
import ninja.trek.chiseledenchanting.ChiseledEnchantingConfig;
import ninja.trek.chiseledenchanting.ChiseledEnchantmentTableBlockEntity;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
@Mixin(EnchantmentScreenHandler.class)
public class EnchantmentScreenHandlerMixin {
    private final Random random = new Random();
    @Inject(method = "generateEnchantments", at = @At("RETURN"), cancellable = true)
    private void modifyEnchantmentProbabilities(DynamicRegistryManager registryManager, ItemStack stack, int slot, int level, CallbackInfoReturnable<List<EnchantmentLevelEntry>> cir) {
        if (!ChiseledEnchantingConfig.get().enableWeighting) {
            return;
        }
        EnchantmentScreenHandler handler = (EnchantmentScreenHandler) (Object) this;
        ((EnchantmentScreenHandlerAccessor) handler).getContext().run((world, pos) -> {
            if (world.getBlockEntity(pos) instanceof ChiseledEnchantmentTableBlockEntity blockEntity) {
                List<EnchantmentLevelEntry> entries = cir.getReturnValue();
                if (entries == null || entries.isEmpty()) return;
                List<EnchantmentLevelEntry> modifiedEntries = new ArrayList<>();
                boolean isBook = stack.isOf(Items.BOOK);
                boolean invertItems = ChiseledEnchantingConfig.get().inverseWeightingForItems; // Global inversion setting
                for (EnchantmentLevelEntry entry : entries) {
                    float boost = blockEntity.getEnchantmentBoost(entry.enchantment.value());
                    // Apply book-specific inversion
                    if (isBook && ChiseledEnchantingConfig.get().inverseWeightingForBooks) {
                        boost = 1.0f / boost;
                    }
                    // Apply general item inversion (but not to books)
                    if (!isBook && invertItems) {
                        boost = 1.0f / boost;
                    }
                    // Ensure at least one copy exists
                    int copies = Math.max(1, Math.round(boost));
                    for (int i = 0; i < copies; i++) {
                        modifiedEntries.add(entry);
                    }
                }
                if (!modifiedEntries.isEmpty()) {
                    List<EnchantmentLevelEntry> finalEntries = new ArrayList<>();
                    finalEntries.add(modifiedEntries.get(random.nextInt(modifiedEntries.size())));
                    cir.setReturnValue(finalEntries);
                }
            }
        });
    }
}
</file>

<file path="main/java/ninja/trek/chiseledenchanting/mixin/ExampleMixin.java">
package ninja.trek.chiseledenchanting.mixin;
import net.minecraft.server.MinecraftServer;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftServer.class)
public class ExampleMixin {
	@Inject(at = @At("HEAD"), method = "loadWorld")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftServer.loadWorld()V
	}
}
</file>

<file path="main/resources/assets/chiseled-enchanting/blockstates/chiseled_enchanting_table.json">
{
  "variants": {
    "": {
      "model": "chiseled-enchanting:block/chiseled_enchanting_table"
    }
  }
}
</file>

<file path="main/resources/assets/chiseled-enchanting/lang/en_us.json">
{
  "config.chiseled-enchanting.option.invert_items": "Invert Items",
  "config.chiseled-enchanting.option.enable_weighting": "Enable Weighting",
  "config.chiseled-enchanting.option.inverse_books": "Invert Books"
}
</file>

<file path="main/resources/assets/chiseled-enchanting/models/block/chiseled_enchanting_table.json">
{
  "parent": "minecraft:block/enchanting_table",
  "textures": {
    "particle": "chiseled-enchanting:block/chiseled_enchanting_table_bottom",
    "bottom": "chiseled-enchanting:block/chiseled_enchanting_table_bottom",
    "top": "chiseled-enchanting:block/chiseled_enchanting_table_top",
    "side": "chiseled-enchanting:block/chiseled_enchanting_table_side"
  }
}
</file>

<file path="main/resources/assets/chiseled-enchanting/models/item/chiseled_enchanting_table.json">
{
  "parent": "chiseled-enchanting:block/chiseled_enchanting_table"
}
</file>

<file path="main/resources/chiseled-enchanting.mixins.json">
{
	"required": true,
	"package": "ninja.trek.chiseledenchanting.mixin",
	"compatibilityLevel": "JAVA_21",
	"mixins": [
		"EnchantmentScreenHandlerMixin",
		"EnchantmentScreenHandlerAccessor"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="main/resources/fabric.mod.json">
{
	"schemaVersion": 1,
	"id": "chiseled-enchanting",
	"version": "${version}",
	"name": "Chiseled Enchanting",
	"description": "This is an example description! Tell everyone what your mod is about!",
	"authors": [
		"Me!"
	],
	"contact": {
		"homepage": "https://fabricmc.net/",
		"sources": "https://github.com/FabricMC/fabric-example-mod"
	},
	"license": "CC0-1.0",
	"icon": "assets/chiseled-enchanting/icon.png",
	"environment": "*",
	"entrypoints": {
		"main": [
			"ninja.trek.chiseledenchanting.ChiseledEnchanting"
		],
		"client": [
			"ninja.trek.chiseledenchanting.ChiseledEnchantingClient"
		],
		"fabric-datagen": [
			"ninja.trek.chiseledenchanting.ChiseledEnchantingDataGenerator"
		],
		"modmenu": [
			"ninja.trek.chiseledenchanting.ChiseledEnchantingModMenu"
		]
	},
	"mixins": [
		"chiseled-enchanting.mixins.json",
		{
			"config": "chiseled-enchanting.client.mixins.json",
			"environment": "client"
		}
	],
	"depends": {
		"fabricloader": ">=0.16.10",
		"minecraft": "~1.21",
		"java": ">=21",
		"fabric-api": "*",
		"cloth-config": ">=11.0.0",
		"modmenu": ">=7.0.0"
	},
	"suggests": {
		"another-mod": "*"
	},
	"custom": {
		"modmenu": {
			"api": "ninja.trek.chiseledenchanting.ChiseledEnchantingModMenu"
		}
	}

}
</file>

<file path="repomixx.bat">
repomix --style xml --remove-empty-lines --copy --ignore "**/generated/**"
</file>

</files>
